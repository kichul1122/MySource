# Architecture

# 객체지향 프로그래밍(OOP: Object-Oriented Programming)
1)문제의 영역에서 배우를 찾아내고
2)각 배우들의 책임과 역할을 정의하고
3)배우들간의 관계를 지정하고
4)각 배우들에 대한 대본을 쓴다

클래스 : 속성(데이터)와 행위(메소드)
객체 : 클래스로부터 실체화 된 것
메소드 : 객채에게 명령, 객체간의 통신 방법

추상화 : 객채에서 공통된 속성과 행위를 추출하는 것
캡슐화 : 정보은닉
상속
다형성 : 오버라이딩

# 객체지향 설계의 기본적인 사고 방식
캡슐화, 응집도, 결합도는 보수성이 높은 클래스를 설계할 때 사용하는 기본 요소

1.캡슐화
객체 내부의 변수 또는 구현 상세를 사용자로부터 은폐하는 것
'직접 하지 말고 명령하라'
인터페이스 사용을 통한 좋은 캡슐화를 실현(사용자는 인터페이스로만 사용)

- 캡슐화의 목적
 1.객체 내부의 상태를 보호
 2.객체의 구현 상세를 은폐

 사용자가 객체 내부 구조를 신경 쓰지 않아도 쉽게 사용할 수 있는 클래스 설계가 중요.

 2.응집도
 클래스가 하나의 역할에 얼마나 집증하는지를 나타내는 척도(여러 역할을 수행하는 클래스는 응집도가 낮다)
 Ex)
 {
	 Game클래스는 다른 클래스 제어 역할
 	Score클래스는 점수계산
 	Timer클래스는 시간제한
 	CharacterManager는 캐릭터 관리
 }

 3.결합도
 다른 클래스와의 연광정도를 나타내는 척도.
 클래스는 가능한 서로 영향을 주지 않는 것이 좋다.
 결합도가 낮은 상태를 '소결합' - 외부 변경에 영향을 받지 않으며, 재사용 또는 테스트가 간편

 # 상속(is-a)과 이양(has-a)
상속은 부모의 힘을 사용하는 관계, 이양은 다른 사람의 힘을 사용하는 관계

1.상속보다는 이양을 사용
상속보다는 이양을 사용하는 편이 설계 측면에서 유연함
상속시 부모와 자식은 매우 밀접하게 결합
상속은 컴파일할 때 결합해서 실행 중일땐 변경 불가, 이양은 실행중에도 변경가능

이양의 장점(인터페이스를 멤버로 가짐으로써 가지는 장점)
1)유연성과 보수성 - 인터페이스를 가짐으로써 구현 클래스의 변경이 영향을 미치지않는다.(느슨한 연결)
2)런타임시 변경이 가능하다.

2.쿨래스를 통한 기능 상속과 인터페이스를 통한 역할 구현
1)부모 클래스로부터 '기능 상속'
2)인터페이스를 통한 '역할 구현'

클래스를 만든다
클래스의 다형성을 부여하고싶다
상속을 할것인가? 이양을 할것인가?
상속 => 클래스를 통한 '기능상속', 인터페이스를 통한 '역할구현' [C#에서는 문법적으로 클래스는 한개만, 인터페스는 여러개 가능]
이양 => 인터페이스를 가지게함으로써 유연함 부여

상속과 인터페이스 구현을 구별하자!

*유니티에서의 이양 : MonoBehaviour에서 멤버로 사용할 객체를 Interface로 접근[사용할 객체는 Interface로 '역할구현'을 한상태 => 사용하는 Monobehavior에서는 사용할 객체의 변경/수정에 영향을 받지않음]

과거 상속기반에서 현재 컴포넌트 기반 방식으로 프레임워크가 바뀐이유가 있기도하다

# 객체 지향 설계의 원칙
1.단일 책임 원칙
하나의 클래스는 하나의 책임만 가져야 한다 => 응집도 높은 클래스

2.개방·폐쇄 원칙
소프트웨어의 구성 요소는 확장에 관해서는 열려있어야하고, 변경에 대해서는 닫혀있어야한다. => 변화하지않는부분(닫힌 부분)과 열린 부분(변화하는 부분)을 분리하자.
상속에서 보면 부모 클래스는 닫힌 부분, 자식클래스는 열린 부분.

3.리스코프 치환 원칙
파생 자료형은 기본 자료형과 치환할 수 있어야 한다 => 부모 클래스로 치환한 상태에서도 정상 작동 해야 한다.
다운캐스트를 해야 할 경우에는 리스코프 치한 원칙에 위반됨.
상속 관계가 복잡해지면 이 원칙을 위반하는 클래스가 만들어질 가능성이 커진다. 다중 상속 또는 깊은 상속 관계를 만드는 일을 피해야한다. 상속에 의존한 설계는 무너지기 쉽다. 근본적인 해결 방법은 '상속보다는 이양을 우선한다'.

4.인터페이스 분리 원칙
클래스 사용자에게 불필요한 인터페이스를 공개하지 말라
인터페이스를 활용해서 공개할 것들만 가지게 하자

5.의존 관계 역전 원칙
상위 모듈은 하위 모듈에 의존하지 않는다. 두 모듈 모두 별도의 추상회돈 것에 의존한다.
인터페이스를 거쳐 하위 모듈을 사용하면 하위 레벨의 모듈과 직접적인 결합을 피할 수 있다. 따라서 하위 모듈의 변경, 교환이 쉬워진다.
프로그램 전체를 계층화 하고 분리할 때 의존 관계 역전 원칙을 사용.
구체적인(직접결합)인 것이 아닌 추상적인 것(느슨한결합)에 의존하자!

6.데메테르 법칙
최소 지식의 원칙
직접적인 친구와만 관련하자
친구 : 자기자신, 자신이 가지는 클래스, 매개변수로 전달한 클래스, 멤버 함수 내부에서 실체화한 클래스
친구의친구 클래스, Singletone패턴을 사용한 외부 클래스와 결합하면 데메테르 법칙에 위반된다.

위반한 경우 => Player player = world.GetManager().Find("Player"); [친구의 친구를 사용]
위반하지 않은 경우 => Player player = world.Find("Player"); [친구를 사용]
"직접하지 말고 명령하라"라는 개념을 의식하며 설계해라.

# 디자인 패턴
과거에 작성한 객체 지향 프로그램에서 반복해 나오는 형태와, 그 해결 방법에 이름을 붙여 패턴화 한 것

[디자인패턴](https://github.com/kichul1122/MySource/tree/master/Assets/DesignPattern)

디자인 패턴의 여러가지 구현방법
Ex)전략패턴 : 변화하는 부분을 클래스화해서 교환할 수 있게 하는 패턴 => 교환할 수 있는 알고리즘
1.추상클래스 또는 인터페이스를 통한 교체
2.템플릿 매개변수를 통한 교체
3.이벤트나 델리게이트를 통한 교체

# 클래스 설계의 기본
모든 클래스가 하나의 역할에 대해 하나의 책임을 갖게 설계하기 => 현실에서의 분업화와 같다. 역할을 정해주고, 책임을 지게한다.

# 클래스의 역할
1.작업 역할 클래스, 관리 역할 클래스
작업 역할 클래스 : 구체적인 구현을 하는 말단 클래스
관리 역할 클래스 : 작업 역할 클래스를 제어

2.중재 역할 클래스
객체들의 조정을 전문으로 담당하는 클래스.
작업 중재가 역할이므로, 다른 역할은 수행하면 안 됨.
Mediator패턴에 해당.
각 각의 클래스들이 중재 역할 클래스에만 여관. 중재자를 사용해 의존 관계를 단순화하기.

3.창구 역할 클래스
작업을 의뢰받고, 실질적인 작업을 다른 클래스에 전달하는 역할.
Facade패턴에 해당.
외부와의 인터페이스 부분을 클래스화하기.

4.생성 역할 클래스
객체 생성을 전문으로 수행하는 공장과 같은 클래스.
Factory Method.
Abstract Factory.
Builder.
Prototype.
Singleton.

5.전용, 범용 클래스

# 클래스의 책임
사용자 측의 코드가 간단해질 수 있또록 담당 클래스에 책임을 제대로 이양하기
Ex)Score클래스가 있다면 Score관련된 기능은 스코어안에 있게하기

# 클래스의 추상도
추상도가 높을 수록 코득 단순해져서 수정 또는 변경에 유연하게 대응 할 수 있다.
추상도를 높이려면 문제의 본질을 파악 할 수 있어야한다.
클래스 설계에서 가장 중요한 부분이다.
클래스 또는 멤버 함수의 추상도를 높이면 구현 상세가 캡슐화되고 코드가 단순해짐.
멤버 함수의 이름에 따라 클래스 추상도가 변화.
클래스 추상도는 캡슐화에 큰 영향을 줌.
클래스 사용자 측의 시점에서부터 탑다운해서 생각하는 편이, 보다 추상도 높은 클래스를 설계할 수 있음.

Ex)
1. if(GetAsyncKeyState(VK_LEFT) != 0) { position.x -= speed * deltaTime; }  [나머지 방향도 있음]
2. if(Input.IsKeyDown(KEY_LEFT)) { position.x -= speed * deltaTime; }		[나머지 방향도 있음]
3. if(Input.IsLeft()) { position.x -= speed * deltaTime; }					[나머지 방향도 있음]
4. position += Input.GetDirection() * speed; deltaTime;						[방향설정을 Input.GetDirection()으로]


# 클래스의 결합

# 인터페이스 사용 방법

# 주의점 또는 테크닉

# 클래스 설계 초급편
# 클래스 설계 중급편
# 클래스 설계 고급편
