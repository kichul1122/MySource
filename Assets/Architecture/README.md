# Architecture

객체지향 프로그래밍(OOP: Object-Oriented Programming)

클래스 : 속성(데이터)와 행위(메소드)
객체 : 클래스로부터 실체화 된 것
메소드 : 객채에게 명령, 객체간의 통신 방법

1.추상화 : 객채에서 공통된 속성과 행위를 추출하는 것
2.캡슐화 : 정보은닉
3.상속
4.다형성 : 오버라이딩

설계원칙
1.단일 책임의 원칙(SRP : Single Responsibility Principle)
하나의 클래스에는 한가지 종류의 책임을 두어야한다 => 코드의 응집력을 높임

2.개방/페쇄의 원칙(OCP : Open-Closed Principle)
확장에 대해서는 개방되어야하지만, 변경에 대해서는 폐쇄되어야한다 => 기존 클래스의 변경을 최소화

3.인터페이스 분리 원칙(ISP : Interface Segregation Principle)
클라이언트는 자신이 사용하지 않는 메소드와 의존 관계를 갖지 않도록 해야 한다 => 메소드 변경에 따른 클래스의 변경을 최소화

4.리스코프 치환 원칙(LSP : Liskov Substituion Principle)
고차원 모듈은 저차원 모듈에 의존하면 안된다 => 추상클래스나 인터페이스에 의존하자

------------------------------------------------------------------------
# 객체지향 설계의 기본적인 사고 방식
캡슐화, 응집도, 결합도는 보수성이 높은 클래스를 설계할 때 사용하는 기본 요소

1.캡슐화
객체 내부의 변수 또는 구현 상세를 사용자로부터 은폐하는 것
'직접 하지 말고 명령하라'
인터페이스 사용을 통한 좋은 캡슐화를 실현(사용자는 인터페이스로만 사용)

- 캡슐화의 목적
 1.객체 내부의 상태를 보호
 2.객체의 구현 상세를 은폐

 사용자가 객체 내부 구조를 신경 쓰지 않아도 쉽게 사용할 수 있는 클래스 설계가 중요.

 2.응집도
 클래스가 하나의 역할에 얼마나 집증하는지를 나타내는 척도(여러 역할을 수행하는 클래스는 응집도가 낮다)
 Ex)
 {
	 Game클래스는 다른 클래스 제어 역할
 	Score클래스는 점수계산
 	Timer클래스는 시간제한
 	CharacterManager는 캐릭터 관리
 }

 3.결합도
 다른 클래스와의 연광정도를 나타내는 척도.
 클래스는 가능한 서로 영향을 주지 않는 것이 좋다.
 결합도가 낮은 상태를 '소결합' - 외부 변경에 영향을 받지 않으며, 재사용 또는 테스트가 간편

 # 상속(is-a)과 이양(has-a)
상속은 부모의 힘을 사용하는 관계, 이양은 다른 사람의 힘을 사용하는 관계

1.상속보다는 이양을 사용
상속보다는 이양을 사용하는 편이 설계 측면에서 유연함
상속시 부모와 자식은 매우 밀접하게 결합
상속은 컴파일할 때 결합해서 실행 중일땐 변경 불가, 이양은 실행중에도 변경가능

이양의 장점(인터페이스를 멤버로 가짐으로써 가지는 장점)
1)유연성과 보수성 - 인터페이스를 가짐으로써 구현 클래스의 변경이 영향을 미치지않는다.(느슨한 연결)
2)런타임시 변경이 가능하다.

2.기능 상속과 추상 인터페이스 구현
1)부모 클래스로부터 '기능 상속'
2)인터페이스를 통한 '역할 구현'

클래스를 만든다
클래스의 다형성을 부여하고싶다
상속을 할것인가? 이양을 할것인가?
상속 => 클래스를 통한 '기능상속', 인터페이스를 통한 '역할구현' [C#에서는 문법적으로 클래스는 한개만, 인터페스는 여러개 가능]
이양 => 인터페이스를 가지게함으로써 유연함 부여

